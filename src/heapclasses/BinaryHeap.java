package heapclasses;

import entities.Entity;

import entities.Single;

public class BinaryHeap {
	private Node heapRoot;
	private int heapSize;
	
	public BinaryHeap() {
		heapRoot = null;
		heapSize = 0;
	}
	
	/**
	 * Creates a new {@code node} holding the given entity and inserts it
	 * into the heap. If the heap is empty, update the root of the heap as the
	 * newly created node. Otherwise, insert it at the end of the heap and
	 * make sure to heapify the node based on the entity's priority.
	 * @param newEntity	The entity to be held by the node
	 * @param priority	The priority of the entity
	 */
	public void insert(Entity newEntity, int priority) {
		if (isEmpty()) {
			// insert as Root
			heapRoot = new Node(newEntity);
		} else {
			// insert at the end of the heap
			insertDown(newEntity, priority);
		}
		
		// inserted another node
		heapSize++;
	}
	
	/**
	 * Removes the root of the heap and heapifies it accordingly
	 */
	public void embark() {
		if (isEmpty()) {
			// nothing to do
			return;
		}
		
		if (heapSize == 1) {
			// just remove the root
			heapRoot = null;
			heapSize = 0;
			return;
		}
		
		// swap with root
		swapNodes(heapRoot, getLastNode());
		
		// the last node now has the old root, delete it
		deleteNode(getLastNode());
		
		// heapify the new root
		maxHeapify(heapRoot);
	}
	
	/**
	 * Prints the ID's of the entities currently in the heap.
	 * Follows pre-order traversal.
	 */
	public void list() {
		preOrder(heapRoot);
	}
	
	/**
	 * If the given entity has a person with a set name, find the node
	 * containing the entity with the corresponding ID and delete that person
	 * from it. If the name is not set, delete the whole entity found.
	 * @param newEntity	An entity containing a person with a possible set name
	 */
	public void delete(Entity newEntity) {
		Node nodeToDelete = findNode(heapRoot, newEntity.getID());
		
		if (nodeToDelete == null) {
			// entityID has not been found, should not happen
			System.out.println("No node has been found "
					+ "for entityID: " + newEntity.getID());
		}
		
		String personName = ((Single)newEntity).getName();
		if (personName == null) {
			// prepare for deletion
			swapNodes(nodeToDelete, getLastNode());
			
			// nodeToDelete has been moved to the end of the heap
			deleteNode(getLastNode());
			
			// heapify
			maxHeapify(nodeToDelete);
		} else {
			// delete person
			nodeToDelete.entity.removePerson(personName);
			
			// heapify
			maxHeapify(nodeToDelete);
		}
	}
	
	/**
	 * @return {@code true} if the root node is not present (the heap is empty)
	 */
	public boolean isEmpty() {
		return heapRoot == null ? true : false;
	}
	
	/**
	 * Based on a binary path where {@code 0 - left} and {@code 1 - right}, 
	 * move through the heap starting at the root. The first digit of the
	 * String doesn't represent anything, so it is skipped.
	 * @param path		The binary string representing the path to be followed
	 * @param skipLast	If {@code true}, the path halts at the last step
	 * @return			The {@node} the path landed on
	 */
	private Node followPath(String path, boolean skipLast) {
		Node currentNode = heapRoot;
		/* the path from the root to the last node;
		 * digit 0 means left, digit 1 means right;
		 * the first digit of the path doesn't represent anything, start
		 * at index 1;
		 */
		
		int steps = path.length();
		
		// if skipLast is true, decrement the number of steps
		if (skipLast) {
			steps--;
		}
		
		for (int i = 1; i < steps; i++) {
			if (path.charAt(i) == '0') {
				currentNode = currentNode.leftChild;
			} else {
				currentNode = currentNode.rightChild;
			}
		}
		
		return currentNode;
	}
	
	/**
	 * Follows the path generated by the {@code heapSize} to land on the last
	 * node of the heap
	 * @return	The last node of the heap
	 */
	private Node getLastNode() {
		String path = Integer.toBinaryString(heapSize);
		
		// false -> don't skip the last step
		return followPath(path, false);
	}
	
	/**
	 * Finds a node whose entity matches the given ID. Firstly called on the
	 * root node, the method recursively moves through the whole heap
	 * @param currentNode	Current node in the recursion
	 * @param entityID		The ID to be searched
	 * @return				The node containing the wanted entity
	 */
	private Node findNode(Node currentNode, String entityID) {
		if (currentNode == null || currentNode.entity.getID().equals(entityID)) {
			// stop
			return currentNode;
		}
		
		Node childNode = null;
		if (currentNode.leftChild != null) {
			childNode = findNode(currentNode.leftChild, entityID);
		}
		if (currentNode.rightChild != null && childNode == null) {
			childNode = findNode(currentNode.rightChild, entityID);
		}
		
		return childNode;
	}
	
	/**
	 * Changes references of the entities stored by two nodes
	 * @param node1
	 * @param node2
	 */
	private void swapNodes(Node node1, Node node2) {
		Entity tmp = node1.entity;
		node1.entity = node2.entity;
		node2.entity = tmp;
	}
	
	/**
	 * Places a node in the adequate position in the max heap, based on the
	 * node's priority.
	 * Upward movement is checked before downward.
	 * Recursively calls itself until there's no need to move the node
	 * @param currentNode	The current node of the recursion
	 */
	private void maxHeapify(Node currentNode) {
		int currentPriority = currentNode.entity.getPriority();
		
		// UPWARD maxHeapify
		if (currentNode.parent != null) {
			int parentPriority = currentNode.parent.entity.getPriority();
			if (currentPriority > parentPriority) {
				swapNodes(currentNode, currentNode.parent);
				maxHeapify(currentNode.parent);
				return;
			}
		}
		
		// DOWNWARD maxHeapify
		Node maxChildNode = null;
		
		boolean leftExists = currentNode.leftChild != null;
		boolean rightExists = currentNode.rightChild != null;
		
		if (leftExists) {
			maxChildNode = currentNode.leftChild;
		}
		if (rightExists) {
			maxChildNode = currentNode.rightChild;
		}
		if (leftExists && rightExists) {
			int leftPriority = currentNode.leftChild.entity.getPriority();
			int rightPriority = currentNode.rightChild.entity.getPriority();
			
			if (leftPriority >= rightPriority) {
				maxChildNode = currentNode.leftChild;
			} else {
				maxChildNode = currentNode.rightChild;
			}
		}
		
		if (maxChildNode == null) {
			/* no 'if' block has been entered,
			 * currentNode has no children, nothing to do
			 */
			return;
		}
		
		int maxChildPriority = maxChildNode.entity.getPriority();
		
		if (maxChildPriority > currentPriority) {
			swapNodes(currentNode, maxChildNode);
			maxHeapify(maxChildNode);
			return;
		}
	}
	
	/**
	 * Creates a new node containing the given entity and places it at the end
	 * of the heap, making sure to heapify the node.
	 * @param newEntity	The entity to be contained by the node
	 * @param priority	The priority of the given entity
	 */
	private void insertDown(Entity newEntity, int priority) {
		// suppose the size has already been incremented, find path
		String path = Integer.toBinaryString(heapSize + 1);
		
		/* the last digit of the path is where the Node should be inserted,
		 * treat separately (one step less);
		 */
		
		// true -> skip the last step
		Node parentNode = followPath(path, true);
		
		Node newNode = new Node(newEntity);
		
		// link parent to child
		if (path.charAt(path.length() - 1) == '0') {
			parentNode.leftChild = newNode;
		} else {
			parentNode.rightChild = newNode;
		}
		
		// link child to parent
		newNode.parent = parentNode;
		
		maxHeapify(newNode);
	}
	
	/**
	 * Recursively print the ID's of the entities contained in the nodes.
	 * Follows pre-order traversal
	 * @param currentNode	The current node of the recursion
	 */
	private void preOrder(Node currentNode) {
		if (currentNode == null) {
			return;
		}
		
		if (currentNode != heapRoot) {
			// the space between prints
			System.out.print(" ");
		}
		
		System.out.print(currentNode.entity.getID());
		preOrder(currentNode.leftChild);
		preOrder(currentNode.rightChild);
	}
	
	/**
	 * Removes a leaf from the heap. Usually it is called on the last node of
	 * the heap.
	 * @param node	The node to be removed
	 */
	private void deleteNode(Node node) {
		// due to adequate swaps, this will only operate on a leaf
		if (node.parent == null) {
			// this is the root
			heapRoot = null;
			return;
		}
		
		// remove any links with the parent
		if (node.parent.leftChild == node) {
			node.parent.leftChild = null;
		} else {
			node.parent.rightChild = null;
		}
		node.parent = null;
		
		heapSize--;
	}
}
